%
% TEXINPUTS=/u/kesmit/src/freebsd/Python-2.4.1/Doc/texinputs:
%           /u/kesmit/src/freebsd/Python-2.4.1/Doc/commontex:
%
\documentclass{manual}

\newcommand{\titleref}{\ref}

\newcommand{\optval}[1]{\textrm{\textit{#1}}}
\newcommand{\macro}[1]{\textbackslash\texttt{#1}}
\newcommand{\question}{\subsection}
\newcommand{\LaTeXtohtml}{{\LaTeX}2html}
\newcommand{\plasTeX}{plas\TeX}
\newenvironment{configuration}[1]{%
    \newcommand{\default}[1]{\hfill\\\textbf{Default:} ##1}%
    \newcommand{\config}[2]{\hfill\\\textbf{Config File:} [ ##1 ] ##2}%
    \newcommand{\options}[1]{\hfill\\\textbf{Command-Line Options:} %
                                     \texttt{##1}}%
    \begin{description}
    \item[\textbf{#1}] \hfill\\
}{\end{description}}

\title{\plasTeX\ --- A Python Framework for Processing \LaTeX\ Documents}
\author{Kevin D. Smith}
\authoraddress{\strong{SAS}\\Email: \email{Kevin.Smith@sas.com}}
\date{18 April 2006}

\makeindex
\makemodindex

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}

\plasTeX\ is a collection of Python frameworks that allow you to convert
\LaTeX\ formatted text into various other document formats.  While \LaTeX\ to
markup converters have been written before, this one is different in 
that it is framework driven and allows you to control all of the 
processes including tokenizing, object creation, and rendering through 
API calls.  Here are the main features and benefits of \plasTeX\ from
the beginning of the conversion process to the end.

\begin{description}
\item[Configurable Command-Line Options] If you use the included command-line
interface to the \plasTeX\ framework, \program{plastex}, you are not limited
by the options that it defines.  While there are many command-line options
defined for its own purposes, you can add your own options that you can 
use in your own classes and renderers.

\item[Low-Level Tokenizing Control] The tokenizer in \plasTeX\ works very 
much like the tokenizer in \TeX\ itself.  In your macro classes, you 
can actually control the draining of tokens and even change category codes.

\item[Document Object] While most other \LaTeX\ converters translate from
\LaTeX\ source another type of markup, \plasTeX\ actually converts the 
document into a document object very similar to the DOM used in XML.
Of course, there are many Python constructs built on top of this object
to make it more Pythonic, so you don't have to deal with the objects using
only DOM methods. What's really nice about this is that you can actually 
manipulate the document object prior to rendering.  While this may be an
esoteric feature, not many other converters let you get between the parser
and the renderer.

\item[Full Rendering Control] In \plasTeX\, you get full control over the
renderer.  There is a Zope Page Template (ZPT) based renderer included for HTML
and XML applications, but that is merely an example of what you can do.
A renderer is simply a collection of callable objects.  During the rendering
process, each node in the document object is passed to the callable object 
in the renderer that has the same name as the node.  What that callable object
does is up to the renderer.  In the case of the ZPT-based renderer, the 
node is simply applied to the template using the \method{expand()} method.
If you don't like ZPT, there is nothing preventing you from populating
a renderer with callables that invoke other types of templates, or functions
that simply generate markup with print statements.  You could even drive
a COM interface to create a MS Word document.
\end{description}


\section{Why Should I Use \plasTeX\ Instead Of...}

There are lots of other \LaTeX\ to HTML, XML, etc. converters out there,
so why should you use \plasTeX?  Here is a list of requirements used to
develop \plasTeX\ which allow it to do things that other converters
can't do.

\begin{itemize}
\item the progromming interface should allow full access to the internals
    of the system (i.e. counters, labels, tokenizing, etc.)
\item the rendering component should be separate from the parsing component
\item it should be possible to generate forms of output other than HTML and XML
\item it should be possible to generate multiple forms of output with
    only one parse step
\item the document should be normalized to a well defined structure
\item counters and references should all be done internally, no auxiliary
    file information from \LaTeX\ should be required
\end{itemize}

If you want specifics about why you should use \plasTeX\ instead of
a particular converter, here are the issues with other converters that
\plasTeX\ attempts to solve.

\paragraph{\LaTeXtohtml}
\LaTeXtohtml\ is probably the world's largest Perl script.  If that isn't
reason enough not to use it, I don't know what is.  Seriously though, 
\LaTeXtohtml\ is extremely complicated and uses lots of ``magic'' under
the covers to do its work.  While this magic works fine for most people,
if you really need to change something that is inherent to the way that
\LaTeXtohtml\ works, it is very painful.  

In addition, \LaTeXtohtml\ is limited to generating HTML code.  The HTML
code is embedded in the Perl code throughout the program, so it is not 
easily configured.  If you don't like the HTML format that the 
\LaTeXtohtml\ developer used, you might be able to get the right behavior
using one of the options, but more than likely, you're going to have to
start messing with the \LaTeXtohtml\ code.  

Another issue with \LaTeXtohtml\ is that all macros are expanded as a 
pre-processing operation.  This means that you can't change category 
codes for special environments like verbatims.  Those are handled using
more magic.

All that said, \LaTeXtohtml\ is quite mature and if you like the way that
it renders HTML, it might just work fine for you.

\paragraph{TeX4ht}

TeX4ht does one really smart thing, it lets \TeX\ do the parsing of the
document and expanding of the macros.  Much of the work in \LaTeXtohtml\
and \plasTeX\ deal with that aspect, and no matter how hard they try, 
they're never going to work exactly like \TeX.  Unfortunately, 
configuring TeX4ht is done mostly through \LaTeX\ commands, which 
can be very frustrating.  

In addition, if you use a lot of custom formatting in your macros, you 
may have to put in lots of conditional code to ``dumb it down'' so that
it looks right when converted to HTML.  In the time that I did use it,
I found it quite difficult to get validating HTML code for even slightly
complex tables.

While I do like the idea behind TeX4ht, I was just never able to get it
to work satifactorily for the projects that I worked on.


\chapter{\protect\program{plastex} --- The Command-Line Interface}


While \plasTeX\ makes it possible to parse \LaTeX\ directly from Python
code, most people will simply use the supplied command-line interface, 
\program{plastex}.  \program{plastex} will invoke the parsing processes
and apply a specified renderer.  By default, \program{plastex} will
convert to HTML, although this can be changed in the \program{plastex}
configuration.  

Invoking \program{plastex} is very simple.  To convert a \LaTeX\ document 
to HTML using all of the defaults, simply type the following at shell prompt.

\begin{verbatim}
plastex mylatex.tex
\end{verbatim}

where \file{mylatex.tex} is the name of your \LaTeX\ file.  The 
\LaTeX\ source will be parsed, all packages will be loaded and macros 
expanded, and converted to HTML.  Hopefully, at this point you will have
a lovely set of HTML files that accurately reflect the \LaTeX\ source 
document.  Unfortunately, converting \LaTeX\ to other formats can be 
tricky, and there are many pitfalls.  If you are getting warnings or
errors while converting your document, you may want to check the FAQ
in the appendix to see if your problem is addressed.

Running \program{plastex} with the default options may not give you output
exactly the way you had envisioned.  Luckily, there are many options
that allow you to change the rendering behavior.  These options are 
described in the following section.


\section{\program{plastex} Options}

There are many options to \program{plastex} that allow you to control
things input and output file encodings, where files are generated and
what the filenames look like, rendering parameters, etc.  While 
\program{plastex} is the interface where the options are specified, for
the most part these options are simply passed to the parser and renderers
for their use.  It is even possible to create your own options for use
in your own Python-based macros and renderers (for more information
see \ref{cusomizeoptions}).  The following options are currently available
on the \program{plastex} command.  They are categorized for convenience. 

\subsection{General Options}

\begin{configuration}{Renderer}
specifies which renderer to use.
\default{XHTML}
\options{\longprogramopt{renderer=\optval{renderer-name}}}
\config{general}{renderer}
\end{configuration}

\begin{configuration}{Configuration files}
specifies a configuration file to load.  This should be the first option
specified on the command-line.
\options{\longprogramopt{config=\optval{config-file}} \programopt{-c \optval{config-file}}}
\config{general}{config}
\end{configuration}


\subsection{Document Properties}

\begin{configuration}{Title for the document}
specifies a title to use for the document instead of the title given
in the \LaTeX\ source document
\options{\longprogramopt{title=\optval{string}}}
\config{document}{title}
\end{configuration}

\begin{configuration}{Table of contents depth}
specifies the number of levels to include in each table of contents.
\options{\longprogramopt{toc-depth=\optval{integer}}}
\config{document}{toc-depth}
\end{configuration}

\begin{configuration}{Display sections in the table of contents that do not create files}
specifies that sections that do not create files should still appear in the
table of contents.  By default, only sections that create files will show
up in the table of contents.
\options{\longprogramopt{toc-non-files}}
\config{document}{toc-non-files}
\end{configuration}


\subsection{Document Links}

The links section of the configuration is a little different than the
others.  The options in the links section are not preconfigured, they
are all user-specified.  The links section includes information 
to be included in the navigation object available on all sections in 
a document.  By default, the section's navigation object includes things
like the previous and next objects in the document, the child nodes, 
the sibling nodes, etc.  The table below lists all of the navigation
objects that are already defined.  The names for these items came from
the link types defined at \url{http://fantasai.tripod.com/qref/Appendix/LinkTypes/ltdef.html}.  Of course, it is up to the renderer to actually make use
of them.

\begin{tableii}{l|l}{var}{Name}{Description}
\lineii{home}{the first section in the document}
\lineii{start}{same as \var{home}}
\lineii{begin}{same as \var{home}}
\lineii{first}{same as \var{home}}
\lineii{end}{the last section in the document}
\lineii{last}{same as \var{end}}
\lineii{next}{the next section in the document}
\lineii{prev}{the previous section in the document}
\lineii{previous}{same as \var{prev}}
\lineii{up}{the parent section}
\lineii{top}{the top section in the document}
\lineii{origin}{same as \var{top}}
\lineii{parent}{the parent section}
\lineii{child}{a list of the subsections}
\lineii{siblings}{a list of the sibling sections}
\lineii{document}{the document object}
\lineii{part}{the current part object}
\lineii{chapter}{the current chapter object}
\lineii{section}{the current section object}
\lineii{subsection}{the current subsection object}
\lineii{navigator}{the top node in the document object}
\lineii{toc}{the node containing the table of contents}
\lineii{contents}{same as \var{toc}}
\lineii{breadcrumbs}{a list of the parent objects of the current node}
\end{tableii}

Since each of these items references an object that is expected to have
a URL and a title, any user-defined fields should contain these as well
(although the URL is optional in some items).  To create a user-defined
field in this object, you need to use two options: one for the title
and one for the URL, if one exists.  They are specified in the config
file as follows:
\begin{verbatim}
[links]
glossary-url=http://myhost.com/glossary
glossary-title=The Glossary
otheropt-title=Another Title
\end{verbatim}

These option names are split on the dash (-) to create a key, before the dash,
and a member, after the dash.  A dictionary is inserted into the navigation
object with the name of the key, and the members are added to that dictionary.
The configuration above would create the following Python dictionary.
\begin{verbatim}
{'glossary':
    {'url':'http://myhost.com/glossary', 
     'title':'The Glossary'},
 'otheropt':
    {'title':'Another Title'}
}
\end{verbatim}

While you can not override a field that is populated by the document, 
there are times when a field isn't populated.  This occurs, for example,
in the \var{prev} field at the beginning of the document, or the 
\var{next} field at the end of the document.  If you specify a \var{prev}
or \var{next} field in your configuration, those fields will be used
when no \var{prev} or \var{next} is available.  This allows you to link
to external documents at those points.


\begin{configuration}{Set document links}
specifies links to be included in the navigation object.  Since at
least two values are needed in the links (key and title, with an optional
URL), the values are grouped in square brackets on the command-line ([~]).
\options{\longprogramopt{links=\optval{[ key optional-url title ]}}}
\end{configuration}


\subsection{Input and Output Files}

If you have a renderer that only generates one file, specifying the output
filename is simple: use the \longprogramopt{filename} option to specify
the name.  However, if the renderer you are using generates multiple
files, things get more complicated.  The \longprogramopt{filename} option
is also capable of handling multiple names, as well as giving you a
templating way to build filenames.

Below is a list of all of the options that affect filename generation.

\begin{configuration}{Characters that shouldn't be used in a filename}
specifies all characters that should not be allowed in a filename.
These characters will be replaced by the value in 
\longprogramopt{bad-filename-chars-sub}.
\default{:~\#\$\%\textasciicircumflex\&*!\textasciitilde`"'=?/{}[]()|<>;\textbackslash,.}
\options{\longprogramopt{bad-filename-chars=\optval{string}}}
\config{files}{bad-chars}
\end{configuration}

\begin{configuration}{String to use in place of invalid characters}
specifies a string to use in place of invalid filename characters (
specified by the \longprogramopt{bad-chars-sub} option)
\default{-}
\options{\longprogramopt{bad-filename-chars-sub}=\optval{string}}
\config{files}{bad-chars-sub}
\end{configuration}

\begin{configuration}{Template to use for output filenames}
specifies the templates to use for generating filenames.  
The filename template is a list of space separated names.  Each name 
in the list is returned once.  An example is shown below.

\begin{verbatim}
index.html toc.html file1.html file2.html
\end{verbatim}

These filenames can also contain variables as described in 
Python's string Templates (e.g. \var{\$title}, \var{\${id}}).  These variables
come from the namespace created in the renderer and include:
\var{\$id}, the ID (i.e. label) of the item, \var{\$title}, the title of the
item, and \var{\$jobname}, the basename of the \LaTeX\ file being processed.  
One special variable is \var{\$num}.  This value in generated dynamically 
whenever a filename with \var{\$num} is requested.  Each time a filename 
with \var{\$num} is successfully generated, the value of \var{\$num}
is incremented.

The values of variables can also be modified by a format specified
in parentheses after the variable.  The format is simply an integer
that specifies how wide of a field to create for integers 
(zero-padded), or, for strings, how many space separated words
to limit the name to.  The example below shows \var{\$num} being padded
to four places and \var{\$title} being limited to five words.

\begin{verbatim}
sect$num(4).html $title(5).html
\end{verbatim}

The list can also contain a wildcard filename (which should be 
specified last).  Once a wildcard name is reached, it is 
used from that point on to generate the remaining filenames.  
The wildcard filename contains a list of alternatives to use as
part of the filename indicated by a comma separated list of 
alternatives surrounded by a set of square brackets ([ ]).
Each of the alternatives specified is tried until a filename is
successfully created (i.e. all variables resolve).  For example,
the specification below creates three alternatives.

\begin{verbatim}
$jobname_[$id, $title, sect$num(4)].html
\end{verbatim}

The code above is expanded to the following possibilities.

\begin{verbatim}
$jobname_$id.html
$jobname_$title.html
$jobname_sect$num(4).html
\end{verbatim}

Each of the alternatives is attempted until one of them succeeds.
Generally, the last one should contain no variables except for
\var{\$num} as a fail-safe alternative.
\options{\longprogramopt{filename=\optval{string}}}
\config{files}{filename}
\end{configuration}

\begin{configuration}{Splitting document into multiple files}
specifies the highest section level that generates a new file.  Each section
in a \LaTeX\ document has a number associated with its hierarchical level.
These levels are -2 for the document, -1 for parts, 0 for chapters,
1 for sections, 2 for subsections, 3 for subsubsections, 4 for paragraphs,
and 5 for subparagraphs.  A new file will be generated for every section
in the hierarchy with a value less than or equal to the value of this 
option.  This means that for the value of 2, files will be generated for
the document, parts, chapters, sections, and subsections.
\default{2}
\options{\longprogramopt{split-level=\optval{integer}}}
\config{files}{split-level}
\end{configuration}

\begin{configuration}{Input Encoding}
specifies which encoding the \LaTeX\ source file is in
\default{utf-8}
\options{\longprogramopt{input-encoding=\optval{string}}}
\config{files}{input-encoding}
\end{configuration}

\begin{configuration}{Output Encoding}
specifies which encoding the output files should use.  
\note{This depends on the output format as well.  While HTML and XML use 
encodings, a binary format like MS Word, would not.}
\default{utf-8}
\options{\longprogramopt{output-encoding=\optval{string}}}
\config{files}{output-encoding}
\end{configuration}

\begin{configuration}{Output Directory}
specifies a directory name to use as the output directory.
\default{\$jobname}
\options{\longprogramopt{dir=\optval{directory}} \programopt{-d \optval{directory}}}
\config{files}{directory}
\end{configuration}


\chapter{\plasTeX\ Frameworks and APIs}

\section{\module{plasTeX.ConfigManager} --- \plasTeX\ Configuration}

\declaremodule{standard}{plasTeX.ConfigManager}
\modulesynopsis{\plasTeX's configuration management system}

The configuration system in \plasTeX\ that parses the command-line options
and configuration files is very flexible.  While many options are setup
by the \plasTeX\ framework, it is possible for you to add your own options.
This is useful if you have macros that may need to be configured by 
configurable options, or if you write a renderer that surfaces special options
to control it.

The config files that \class{ConfigManager} supports are standard INI-style
files.  This is the same format supported by Python's \class{ConfigParser}.
However, this API has been extended with some dictionary-like behaviors
to make it more Python friendly.

In addition to the config files, \class{ConfigManager} can also parse
command-line options and merge the options from the command-line into
the options set by the given config files.  In fact, when adding options
to a \class{ConfigManager}, you specify both how they appear in the config
file as well as how they appear on the command-line.  Below is a basic 
example.

\begin{verbatim}
from plasTeX.ConfigManager import *
c = ConfigManager()

# Create a new section in the config file.  This corresponds to the
# [ sectionname ] sections in an INI file.  The returned value is 
# a reference to the new section
d = c.add_section('debugging')

# Add an option to the 'debugging' section called 'verbose'.
# This corresponds to the config file setting:
#
# [debugging]
# verbose = no
#
d['verbose'] = BooleanOption(
    """ Increase level of debugging information """,
    options = '-v --verbose !-q !--quiet',
    default = False,
)

# Read system-level config file
c.read('/etc/myconfig.ini')

# Read user-level config file
c.read('~/myconfig.ini')

# Parse the current command-line arguments
opts, args = c.getopt(sys.argv[1:])

# Print the value of the 'verbose' option in the 'debugging' section
print c['debugging']['verbose']
\end{verbatim}

One interesting thing to note about retrieving values from a 
\class{ConfigManager} is that you get the value of the option
rather than the option instance that you put in.  For example, in the
code above.  A \class{BooleanOption} in put into the `verbose' option
slot, but when it is retrieved in the \function{print} statement at
the end, it prints out a boolean value.  This is true of all option
types.  You can access the option instance in the \member{data} attribute
of the section (e.g. \code{c['debugging'].data['verbose']}).


\subsection{ConfigManager Objects}

\begin{classdesc}{ConfigManager}{defaults=\{~\}}
Instantiate a configuration class for \plasTeX\ that parses the command-line options
as well as reads the config files.  

The optional argument, \var{defaults},
is a dictionary of default values for the configuration object.  These 
values are used if a value is not found in the requested section.
\end{classdesc}

\begin{methoddesc}[ConfigManager]{copy}{}
return a deep copy of the configuration
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{has\_category}{key, title}
add a category to group options when printing the command-line help.
Command-line options can be grouped into categories to make options easier
to find when printing the usage message for a program.  Categories consist
of two pieces: 1) the name, and 2) the title.  The name is the key in
the category dictionary and is the name used when specifying which category
an option belongs to.  The title is the actual text that you see as a 
section header when printing the usage message.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{get\_category}{key}
return the title of the given category
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{categories}{}
return the dictionary of categories
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{defaults}{}
return the dictionary of default values
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{sections}{}
return a list of all section names in the configuration
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{add\_section}{name}
create a new section in the configuration with the given name.  This 
name is the name used for the section heading in the INI file (i.e. the
name used within square brackets (\lbrack~\rbrack) to start a section).
The return value of this method is a reference to the newly created section.  
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{has\_section}{name}
return a boolean indicating whether or not a section with the given name exists
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{options}{name}
return a list of configured option names within a section.  Options are all
of the settings of a configuration file within a section (i.e. the lines that 
start with `optionname=').
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{has\_option}{section, name}
return a boolean indicating whether or not an option with the given name exists
in the given section
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{read}{filenames}
read configuration data contained in files specified by \var{filenames}.
Files that cannot be opened are silently ignored.  This is designed so that
you can specify a list of potential configuration file locations (e.g.
current directory, user's home directory, system directory), and all 
existing configuration files in the list will be read.  A single filename
may also be given.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{readfp}{fp, filename=None}
like \method{read()}, but the argument is a file object.  The optional
\var{filename} argument is used for printing error messages.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{get}{section, option, raw=0, vars=\{~\}}
retrieve the value of \var{option} from the section \var{section}.
Setting \var{raw} to true prevents any string interpolation from occurring
in that value.  \var{vars} is a dictionary of addition value to use 
when interpolating values into the option.

\note{You can alsouse the alternative dictionary syntax: config[section].get(option).}
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{set}{section, option, value}
set the value of an option
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getint}{section, option}
retrieve the specified value and cast it to and integer
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getfloat}{section, option}
retrieve the specified value and cast it to a float
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getboolean}{section, option}
retrieve the specified value and cast it to a boolean
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getraw}{section, option}
return the raw (i.e. un-interpolated) value of the option
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{write}{fp}
write the configuration as an INI formatted string to the given file object
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{\_\_str\_\_}{}
return the configuration as an INI formatted string; however, do not 
include options that were set from Python code.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{\_\_repr\_\_}{}
return the configuration as an INI formatted string; this also includes 
options that were set from Python code.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{to\_string}{source=...}
return the configuration as an INI formatted string.  The \var{source}
option indicates which source of information should be included in
the resulting INI file.  The possible values are:
\begin{tableii}{l|l}{var}{Name}{Description}
\lineii{COMMANDLINE}{set from a command-line option}
\lineii{CONFIGFILE}{set from a configuration file}
\lineii{BUILTIN}{set from Python code}
\lineii{ENVIRONMENT}{set from an environment variable}
\end{tableii}
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{remove\_option}{section, option}
remove the specified option from the given section
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{remove\_section}{section}
remove the specified section
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{get\_opt}{section, option}
return the option value with any leading and trailing quotes removed
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{get\_optlist}{section, option, delim=','}
return the option value as a list using \var{delim} as the delimiter
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{\_\_add\_\_}{other}
merge items from another \class{ConfigManager}.  This allows you to add
\class{ConfigManager} instances with syntax like: config + other. 
This operation will modify the original instance.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{\_\_iadd\_\_}{other}
merge items from another \class{ConfigManager}.  This allows you to add
\class{ConfigManager} instances with syntax like: config += other.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{\_\_radd\_\_}{other}
merge items from another \class{ConfigManager}.  This allows you to add
\class{ConfigManager} instances with syntax like: other + config.
This operation will modify the original instance.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getopt}{args=None, merge=True}
parse the command-line options.  If \var{args} is not given, the 
args are parsed from \code{sys.argv[1:]}.  If \var{merge} is set to false,
then the options are not merged into the configuration.  The return value
is a two element tuple.  The first value is a list of parsed options
in the form \code{(option, value)}, and the second value is the list of
arguments.
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{usage}{categories=[]}
print the descriptions of all command-line options.  If \var{categories}
is specified, only the command-line options from those categories is printed.
\end{methoddesc}


\subsection{ConfigSection Objects}

\begin{classdesc}{ConfigSection}{name, data=\{~\}}
Instantiate a \class{ConfigSection} object.  

\var{name} is the name of the section.

\var{data}, if specified, is the dictionary of data to initalize
the section contents with.
\end{classdesc}

\class{ConfigSection} objects are rarely instantiated manually.  They 
are generally created using the \class{ConfigManager} API (either the 
direct methods or the Python dictionary syntax).


\begin{memberdesc}[ConfigSection]{data}
dictionary that contains the option instances.  This is only accessed
if you want to retrieve the real option instances.  Normally, you would
use standard dictionary key access syntax on the section itself to
retrieve the option values.
\end{memberdesc}

\begin{memberdesc}[ConfigSection]{name}
the name given to the section.
\end{memberdesc}

\begin{memberdesc}[ConfigSection]{parent}
a reference to the parent \class{ConfigManager} object.
\end{memberdesc}

\begin{methoddesc}[ConfigSection]{copy}{}
make a deep copy of the section object.
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{defaults}{}
return the dictionary of default options associated with the parent
\class{ConfigManager}.
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{\_\_getitem\_\_}{key}
retrieve the value of an option.  This method allows you to use Python's 
dictionary syntax on a section as shown below.
\begin{verbatim}
# Print the value of the 'optionname' option
print mysection['optionname'] 
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{set}{option, value}
create a new option or set an existing option with the name 
\var{option} and the value of \var{value}.
If the given value is already an option instance, it is simply inserted
into the section.  If it is not an option instance, an appropriate type
of option is chosen for the given type.
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{\_\_setitem\_\_}{key, value}
create a new option or set an existing option with the name \var{key} and
the value of \var{value}.  This method allows you to use Python's 
dictionary syntax to set options as shown below.
\begin{verbatim}
# Create a new option called 'optionname'
mysection['optionname'] = 10
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getint}{section, option}
retrieve the specified value and cast it to and integer
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getfloat}{section, option}
retrieve the specified value and cast it to a float
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getboolean}{section, option}
retrieve the specified value and cast it to a boolean
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{getraw}{section, option}
return the raw (i.e. un-interpolated) value of the option
\end{methoddesc}

\begin{methoddesc}[ConfigManager]{get}{option, raw=0, vars=\{~\}}
retrieve the value of \var{option}.
Setting \var{raw} to true prevents any string interpolation from occurring
in that value.  \var{vars} is a dictionary of addition value to use 
when interpolating values into the option.

\note{You can alsouse the alternative dictionary syntax: section.get(option).}
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{to\_string}{\optional{source}}
return a string containing an INI file representation of the section.
The \var{source} option allows you to only display options from 
certain sources.  See the \method{ConfigManager.source()} method for more
information.
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{\_\_str\_\_}{}
return a string containing an INI file representation of the section.
Options set from Python code are not included in this representation.
\end{methoddesc}

\begin{methoddesc}[ConfigSection]{\_\_repr\_\_}{}
return a string containing an INI file representation of the section.
\end{methoddesc}


\subsection{Configuration Option Types}

There are several option types that should cover just about any type 
of command-line and configuration option that you may have.  However,
in the spirit of object-orientedness, you can, of course, subclass
one of these and create your own types.  \class{GenericOption} is the 
base class for all options.  It contains all of the underlying framework
for options, but should never be instantiated directly.  Only subclasses
should be instantiated.

\begin{classdesc}{GenericOption}{
    \optional{docstring
    \optional{, options
    \optional{, default
    \optional{, optional
    \optional{, values
    \optional{, category
    \optional{, callback
    \optional{, synopsis
    \optional{, environ
    \optional{, registry
    \optional{, mandatory
    \optional{, name
    \optional{, source
    }}}}}}}}}}}}}
}
Declare a command line option.

Instances of subclasses of \class{GenericOption} must be placed in
a \class{ConfigManager} instance to be used.  See the documentation for
\class{ConfigManager} for more details.

\var{docstring} is a string in the format of Python documentation
   strings that describes the option and its usage.  The first
   line is assumed to be a one-line summary for the option.
   The following paragraphs are assumed to be a complete description
   of the option.  You can give a paragraph with the label
   'Valid Values:' that contains a short description of the
   values that are valid for the current option.  If this
   paragraph exists and an error is encountered while validating
   the option, this paragraph will be printed instead of the
   somewhat generic error message for that option type.

\var{options} is a string containing all possible variants of the
   option.  All variants should contain the '-', '--', etc. at
   the beginning.  For boolean options, the option can be preceded
   by a '!' to mean that the option should be turned OFF rather
   than ON which is the default.

\var{default} is a value for the option to take if it isn't specified
   on the command line

\var{optional} is a value for the option if it is given without a value.
   This is only used for options that normally take a value,
   but you also want a default that indicates that the option
   was given without a value.

\var{values} defines valid values for the option.  This argument can take
   the following forms:
        

\begin{tableii}{l|l}{var}{Type}{Description}
   \lineii{single value}{for \class{StringOption} this this is a string, for
      \class{IntegerOption} this is an integer, for \class{FloatOption} this is
      a float.  The single value mode is most useful when the 
      value is a regular expression.  For example, to specify
      that a \class{StringOption} must be a string of characters followed
      by a digit, 'values' would be set to \code{re.compile(r'{\textbackslash}w+{\textbackslash}d')}.}
   \lineii{range of values}{a two element list can be given to specify
      the endpoints of a range of valid values.  This is probably
      most useful on \class{IntegerOption} and \class{FloatOption}.  
      For example, to specify that an IntegerOption can only take the values
      from 0 to 10, 'values' would be set to [0,10]. 
      \note{This mode must \emph{always} use a Python list since using
            a tuple means something else entirely.}}
   \lineii{tuple of values}{a tuple of values can be used to specify 
      a complete list of valid values.  For example, to specify
      that an \class{IntegerOption} can take the values 1, 2, or 3, 'values'
      would be set to \code{(1,2,3)}.  If a string value can only take 
      the values, 'hi', 'bye', and any string of characters beginning
      with the letter 'z', 'values' would be set to 
      \code{('hi','bye',re.compile(r'z.*?'))}.
      \note{This mode must *always* use a Python tuple since using
            a list means something else entirely.}}
\end{tableii}

\var{category} is a category key which specifies which category the
   option belongs to (see the \class{ConfigManager} documentation on 
   how to create categories).

\var{callback} is a function to call after the value of the option has
   been validated.  This function will be called with the validated
   option value as its only argument.

\var{environ} is an environment variable to use as default value instead
   of specified value.  If the environment variable exists, it
   will be used for the default value instead of the specified value.

\var{registry} is a registry key to use as default value instead of
   specified value.  If the registry key exists, it will be used
   for the default value instead of the specified value.  A
   specified environment variable takes precedence over this value.
   \note{This is not implemented yet.}

\var{name} is a key used to get the option from its corresponding section.
   You do not need to specify this.  It will be set automatically
   when you put the option into the \class{ConfigManager} instance.

\var{mandatory} is a flag used to determine if the option itself is
   required to be present.  The idea of a "mandatory option" is
   a little strange, but I have seen it done.

\var{source} is a flag used to determine whether the option was set
   directly in the \class{ConfigManager} instance through Python,
   by a configuration file/command line option, etc.  You do not need
   to specify this, it will be set automatically during parsing.
   This flag should have the value of \var{BUILTIN}, \var{COMMANDLINE},
   \var{CONFIGFILE}, \var{ENVIRONMENT}, \var{REGISTRY}, or \var{CODE}.
\end{classdesc}

\begin{methoddesc}[GenericOption]{cast}{arg}
cast the given value to the appropriate type.
\end{methoddesc}

\begin{methoddesc}[GenericOption]{getValue}{\optional{default}}
return the current value of the option.  If \var{default} is specified
and a value cannot be gotten from any source, it is returned.
\end{methoddesc}

\begin{methoddesc}[GenericOption]{clearValue}{}
reset the value of the option as if it had never been set.
\end{methoddesc}

\begin{methoddesc}[GenericOption]{\_\_repr\_\_}{}
return a string containing a command-line representation of the option and
its value.
\end{methoddesc}

\begin{methoddesc}[GenericOption]{checkValues}{value}
check \var{value} against all possible valid values for the option.
If the value is invalid, raise an \exception{InvalidOptionError} exception.
\end{methoddesc}

\begin{methoddesc}[GenericOption]{acceptsArgument}{}
return a boolean indicating whether or not the option accepts an argument on 
the command-line.  For example, boolean options do not accept an argument.
\end{methoddesc}

\begin{methoddesc}[GenericOption]{requiresArgument}{}
return a boolean indicating whether or not the option requires an argument
on the command-line.
\end{methoddesc}

As mentioned previously, \class{GenericOption} is an abstract class 
(i.e. it should not be instantiated directly).  Only subclasses of 
\class{GenericOption} should be instantiated.  Below are some examples
of use of some of these subclasses, followed by the descriptions
of the subclasses themselves.

\begin{verbatim}
   BooleanOption(
      ''' Display help message ''',
      options = '--help -h',
      callback = usage,  # usage() function must exist prior to this
   )

   BooleanOption(
      ''' Set verbosity ''',
      options = '-v --verbose !-q !--quiet',
   )

   StringOption(
      '''
      IP address option

      This option accepts an IP address to connect to.

      Valid Values:
      '#.#.#.#' where # is a number from 1 to 255

      ''',
      options = '--ip-address',
      values = re.compile(r'\d{1,3}(\.\d{1,3}){3}'),
      default = '127.0.0.0',
      synopsis = '#.#.#.#',
      category = 'network',  # Assumes 'network' category exists
   )

   IntegerOption(
      '''
      Number of seconds to wait before timing out

      Valid Values:
      positive integer

      ''',
      options = '--timeout -t',
      default = 300,
      values = [0,1e9],
      category = 'network',
   )

   IntegerOption(
      '''
      Number of tries to connect to the host before giving up

      Valid Values:
      accepts 1, 2, or 3 retries

      ''',
      options = '--tries',
      default = 1,
      values = (1,2,3),
      category = 'network',
   )

   StringOption(
      '''
      Nonsense option for example purposes only

      Valid Values:
      accepts 'hi', 'bye', or any string beginning with the letter 'z'

      ''',
      options = '--nonsense -n',
      default = 'hi',
      values = ('hi', 'bye', re.compile(r'z.*?')),
   )
\end{verbatim}

\begin{classdesc}{BooleanOption}{\optional{\class{GenericOption} arguments}}
Boolean options are simply options that allow you to specify an `on' or 
`off' state.  The accepted values for a boolean option in a config file
are `on', `off', `true', `false', `yes', `no', 0, and 1.  Boolean options on
the command-line do not take an argument; simply specifying the option
sets the state to true.

One interesting feature of boolean options is in specifying the command-line
options.  Since you cannot specify a value on the command-line (the existence
of the option indicates the state), there must be a way to set the state to
false.  This is done using the `not' operator (!).  When specifying the 
\var{options} argument of the constructor, if you prefix an command-line 
option with an exclamation point, the existence of that option indicates
a false state rather than a true state.  Below is an example of an \var{options}
value that has a way to turn debugging information on (\longprogramopt{debug}) 
or off (\longprogramopt{no-debug}).
\begin{verbatim}
BooleanOption( options = '--debug !--no-debug' )
\end{verbatim}
\end{classdesc}

\begin{classdesc}{CompoundOption}{\optional{\class{GenericOption} arguments}}
Compound options are options that contain multiple elements on the 
command-line.  They are simply groups of command-line arguments surrounded
by a pair of grouping characters (e.g. (~), [~], \{~\}, <~>).  This grouping
can contain anything including other command-line arguments.  However, 
all content between the grouping characters is unparsed.  This can be useful
if you have a program that wraps another program and you want to be able
to forward the wrapped program's options on.  An example of a compound option
used on the command-line is shown below.
\begin{verbatim}
# Capture the --diff-opts options to send to another program
mycommand --other-opt --diff-opts ( -ib --minimal ) file1 file2
\end{verbatim}
\end{classdesc}

\begin{classdesc}{CountedOption}{\optional{\class{GenericOption} arguments}}
A \class{CountedOption} is a boolean option that keeps track of how many
times it has been specified.  This is useful for options that control 
the verbosity of logging messages in a program where the number of times
an option is specified, the more logging information is printed.
\end{classdesc}

\begin{classdesc}{InputDirectoryOption}{\optional{\class{GenericOption} arguments}}
An \class{InputDirectoryOption} is an option that accepts a directory name
for input.
This directory name is checked to make sure that it exists and that it is
readable.  If it is not, a \exception{InvalidOptionError} exception is 
raised.
\end{classdesc}

\begin{classdesc}{OutputDirectoryOption}{\optional{\class{GenericOption} arguments}}
An \class{OutputDirectoryOption} is an option that accepts a directory name
for output.  If the directory exists, it is checked to make sure that it is
readable.  If it does not exist, it is created.
\end{classdesc}

\begin{classdesc}{InputFileOption}{\optional{\class{GenericOption} arguments}}
An \class{InputFileOption} is an option that accepts a file name for input.
The filename is checked to make sure that it exists and is readable.  If
it isn't, an \exception{InvalidOptionError} exception is raised.
\end{classdesc}

\begin{classdesc}{OutputFileOption}{\optional{\class{GenericOption} arguments}}
An \class{OutputFileOption} is an option that accepts a file name for output.
If the file exists, it is checked to make sure that it is writable.  
If a name contains a directory, the path is checked to make sure that it is 
writable.  If the directory does not exist, it is created. 
\end{classdesc}

\begin{classdesc}{FloatOption}{\optional{\class{GenericOption} arguments}}
A \class{FloatOption} is an option that accepts a floating point number.
\end{classdesc}

\begin{classdesc}{IntegerOption}{\optional{\class{GenericOption} arguments}}
An \class{IntegerOption} is an option that accepts an integer value.
\end{classdesc}

\begin{classdesc}{MultiOption}{\optional{\class{GenericOption} arguments, \optional{delim, \optional{range, \optional{template}}}}}
A \class{MultiOption} is an option that is intended to be used multiple times
on the command-line, or take a list of values.  Other options when specified
more than once simply overwrite the previous value.  \class{MultiOption}s
will append the new values to a list.

The delimiter used to separate multiple values is the comma (,).  A different
character can be specified in the \var{delim} argument.  

In addition, it is possible to specify the number of values that are legal
in the \var{range} argument.  The range argument takes a two element list.
The first element is the minimum number of times the argument is required.
The second element is the maximum number of times it is required.  You can
use a `*' (in quotes) to mean an infinite number.

You can cast each element in the list of values to a particular type by
using the \var{template} argument.  The \var{template} argument takes a
reference to the option class that you want the values to be converted to.
\end{classdesc}

\begin{classdesc}{StringOption}{\optional{\class{GenericOption} arguments}}
A \class{StringOption} is an option that accepts an arbitrary string.
\end{classdesc}


\section{\module{plasTeX.DOM} --- The \plasTeX\ Document Object Model (DOM)}

\declaremodule{standard}{plasTeX.DOM}
\modulesynopsis{The Document Object Model (DOM) used by \plasTeX.}

While most \LaTeX\ processors use a stream model where the input is 
directly connected to the output, \plasTeX\ actually works in two phases.
The first phase reads in the \LaTeX\ document, expands macros, and
constructs an object similar to an XML DOM.  This object is then passed
to the renderer which translates it into the appropriate output format.
The benefit to doing it this way is that you are not limited to a single
output format.  In addition, you can actually apply multiple renderers
with only one parse step.  This section describes the DOM used by 
\plasTeX, its API, and the similarities and differences between the 
\plasTeX\ DOM and the XML DOM.

\subsection{\plasTeX\ vs. XML}

The \plasTeX\ DOM and XML DOM have more similarities than differences.
This similarity is purely intentional to reduce the learning curve and
to prevent reinventing the wheel.  However, the XML DOM can be a bit 
cumbersome especially when you're used to much simpler and more elegant
Python code.  Because of this, some Python behaviors were adopted into
the \plasTeX\ DOM.  The good news is that these extensions do not break
compatibility with the XML DOM.  There are, however, some differences 
due to conventions used \LaTeX.  

The only significant difference between the \plasTeX\ DOM and the XML DOM is 
that \plasTeX\ nodes do not have true attributes like in XML.  Attributes in XML
are more like arguments in \LaTeX, because they are similar the \plasTeX\
DOM actually puts the \LaTeX\ macro arguments into the \member{attributes}
dictionary.  This does create an incompatibility though since XML DOM
attributes can only be strings whereas \LaTeX\ arguments can contain 
lots of markup.  In addition, \plasTeX\ allows you to convert these 
arguments into Python strings, lists, dictionaries, etc., so essentially
any type of object can occur in the \member{attributes} dictionary.

Other than paying attention to the the attributes dictionary difference,
you can use most other XML DOM methods on \plasTeX\ document objects to
create nodes, delete nodes, etc.  The full API is described below.

In most cases, you will not need to be concerned with instantiating nodes.
The \plasTeX\ framework does this.  However, the API can be helpful if you
want to modify the document object that \plasTeX\ creates.


\subsection{Node Objects}

\begin{classdesc}{Node}{}
The \class{Node} class is the base class for all nodes in the
\plasTeX\ DOM inluding elements, text, etc.
\end{classdesc}

\begin{memberdesc}[Node]{unicode}
specifies a unicode string that could be used in place of the node.
This unicode string will be converted into tokens in the \plasTeX\ 
output stream.
\end{memberdesc}

\begin{memberdesc}[Node]{isElementContentWhitespace}
boolean indicating whether or not the node only contains whitespace.
\end{memberdesc}

\begin{memberdesc}[Node]{nodeName}
the name of the node.  This is either the special node name as specified
in the XML DOM (e.g. \#document-fragment, \#text, etc.), or, if the
node corresponds to an element, it is the name of the element.
\end{memberdesc}

\begin{memberdesc}[Node]{nodeType}
integer indicating the type of the node.  The node types are defined as:
\begin{itemize}
\item \member{Node.ELEMENT\_NODE}
\item \member{Node.ATTRIBUTE\_NODE}
\item \member{Node.TEXT\_NODE}
\item \member{Node.CDATA\_SECTION\_NODE}
\item \member{Node.ENTITY\_REFERENCE\_NODE}
\item \member{Node.ENTITY\_NODE}
\item \member{Node.PROCESSING\_INSTRUCTION\_NODE}
\item \member{Node.COMMENT\_NODE}
\item \member{Node.DOCUMENT\_NODE}
\item \member{Node.DOCUMENT\_TYPE\_NODE}
\item \member{Node.DOCUMENT\_FRAGMENT\_NODE}
\item \member{Node.NOTATION\_NODE}
\end{itemize}
\note{These are defined by the XML DOM, not all of them are used by \plasTeX.}
\end{memberdesc}

\begin{memberdesc}[Node]{parentNode}
refers to the node that contains this node
\end{memberdesc}

\begin{memberdesc}[Node]{attributes}
a dictionary containing the attributes, in the case of \plasTeX\, the 
\LaTeX\ macro arguments
\end{memberdesc}

\begin{memberdesc}[Node]{previousSibling}
the node in the document that is adjacent to and immediately before this 
node.  If one does not exist, the value is \var{None}.
\end{memberdesc}

\begin{memberdesc}[Node]{nextSibling}
the node in the document that is adjacent to and immediately after this 
node.  If one does not exist, the value is \var{None}.
\end{memberdesc}

\begin{memberdesc}[Node]{lastChild}
the last node in the \member{childNodes} list.  If there are no child nodes,
the value is \var{None}.
\end{memberdesc}

\begin{memberdesc}[Node]{childNodes}
a list of the nodes that are contained by this one.  In \plasTeX, this 
generally contains the contents of a \LaTeX\ environment.
\end{memberdesc}

\begin{memberdesc}[Node]{ownerDocument}
the node that owner of, and ultimate parent of, all nodes in the document
\end{memberdesc}

\begin{memberdesc}[Node]{textContent}
contains just the text content of this node
\end{memberdesc}

\begin{memberdesc}[Node]{userdata}
dictionary used for holding user-defined data
\end{memberdesc}

\begin{methoddesc}[Node]{toXML}{}
return an XML representation of the node
\end{methoddesc}

\begin{methoddesc}[Node]{hasChildNodes}{}
returns a boolean indicating whether or not the node has child nodes
\end{methoddesc}

\begin{methoddesc}[Node]{insertBefore}{newChild, refChild}
inserts \var{newChild} before \var{refChild} in this node.  If \var{refChild}
is not found, a \exception{NotFoundErr} exception is raised.
\end{methoddesc}

\begin{methoddesc}[Node]{replaceChild}{newChild, oldChild}
replaces \var{oldChild} with \var{newChild} in this node.  If \var{oldChild}
is not found, a \exception{NotFoundErr} exception is raised.
\end{methoddesc}

\begin{methoddesc}[Node]{removeChild}{oldChild}
removes \var{oldChild} from this node.  If \var{oldChild} is not found,
a \exception{NotFoundErr} exception is raised.
\end{methoddesc}

\begin{methoddesc}[Node]{pop}{index=-1}
removes child node and the index given by \var{index}.  If no index is
specified, the last child is removed.
\end{methoddesc}

\begin{methoddesc}[Node]{append}{newChild}
adds a new child to the end of the child nodes
\end{methoddesc}

\begin{methoddesc}[Node]{appendChild}{newChild}
same as \method{append}
\end{methoddesc}

\begin{methoddesc}[Node]{insert}{i, newChild}
inserts node \var{newChild} into position \var{i} in the child nodes list
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_setitem\_\_}{i, node}
sets the item at index \var{i} to \var{node}.  This allows you to use 
Python's slicing syntax to insert child nodes; see the example below.
\begin{verbatim}
mynode[5] = othernode
mynode[6:10] = [node1, node2]
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[Node]{extend}{other}
appends \var{other} to list of children then returns \var{self}
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_iadd\_\_}{other}
same as \method{extend}.  This allows you to use nodes in Python statements
like: node += other.
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_radd\_\_}{other}
create a new node that is the sum of \var{other} and \var{self}.  This
allows you to use nodes in Python statements like: other + node.
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_add\_\_}{other}
create a new node that is the sum of \var{self} and \var{other}.  This
allows you to use nodes in Python statements like: node + other.
\end{methoddesc}

\begin{methoddesc}[Node]{cloneNode}{deep=False}
create a clone of the current node.  If \var{deep} is true, then the 
attributes and child nodes are cloned as well.  Otherwise, all references
to attributes and child nodes will be shared between the nodes.
\end{methoddesc}

\begin{methoddesc}[Node]{normalize}{}
combine consecutive text nodes and remove comments in this node
\end{methoddesc}

\begin{methoddesc}[Node]{hasAttributes}{}
returns a boolean indicating whether or not this node has attributes defined
\end{methoddesc}

\begin{methoddesc}[Node]{isSameNode}{other}
indicates whether the given node is the same node as this one
\end{methoddesc}

\begin{methoddesc}[Node]{isEqualNode}{other}
indicates whether the given node is equivalent to this one
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_cmp\_\_}{other}
same as \method{isEqualNode}, but allows you to compare nodes using the
Python statement: node == other.
\end{methoddesc}

\begin{methoddesc}[Node]{setUserData}{key, data}
put data specified in \var{data} into the \member{userdata} dictionary under the
name given by \var{key}
\end{methoddesc}

\begin{methoddesc}[Node]{getUserData}{key}
retrieves the data in the \member{userdata} dictionary under the name \var{key}
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_iter\_\_}{}
returns an iterator that iterates over the child nodes.  This allows you to
use Python's \function{iter()} function on nodes.
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_len\_\_}{}
returns the number of child nodes.  This allows you to use Python's 
\function{len()} function on nodes.
\end{methoddesc}

\begin{methoddesc}[Node]{\_\_getitem\_\_}{i}
returns the child node at the index given by \var{i}.  This allows you to
use Python's slicing syntax to retrieve child nodes: node[i].
\end{methoddesc}


\subsection{DocumentFragment Objects}

\begin{classdesc}{DocumentFragment}{}
A collection of nodes that make up only part of a document.  This is 
mainly used to hold the content of a \LaTeX\ macro argument.
\end{classdesc}


\subsection{Element Objects}

\begin{classdesc}{Element}{}
The base class for all element-type nodes in a document.  Elements generally
refer to nodes created by \LaTeX\ commands and environments.
\end{classdesc}

\begin{methoddesc}[Element]{getAttribute}{name}
returns the attribute specified by \var{name}
\end{methoddesc}

\begin{methoddesc}[Element]{setAttribute}{name, value}
sets the attribute \var{value} in the \member{attributes} dictionary
using the key \var{name}
\end{methoddesc}

\begin{methoddesc}[Element]{removeAttribute}{name}
removes the attribute \var{name} from the \member{attributes} dictionary
\end{methoddesc}

\begin{methoddesc}[Element]{hasAttribute}{name}
returns a boolean indicating whether or not the specified attribute exists
\end{methoddesc}

\begin{methoddesc}[Element]{getElementsByTagName}{tagName}
retrieve all nodes with the given name in the node
\end{methoddesc}

\begin{methoddesc}[Element]{getElementById}{elementId}
retrieve the element with the given ID
\end{methoddesc}


\subsection{Text Objects}

\begin{classdesc}{Text}{}
This is the node type used for all text data in a document object.
Unlike XML DOM text nodes, text nodes in \plasTeX\ are 
not mutable.  This is because they are a subclass of \var{unicode}.
This means that they will respond to all of the standard Python
string methods in addition to the \class{Node} methods and the methods
described below.
\end{classdesc}

\begin{memberdesc}[Text]{nodeValue}
the text content of the node
\end{memberdesc}

\begin{memberdesc}[Text]{length}
the length of the text content
\end{memberdesc}

\begin{memberdesc}[Text]{data}
the text content of the node
\end{memberdesc}

\begin{memberdesc}[Text]{wholeText}
returns the text content from the current text node as well as its siblings
\end{memberdesc}


\subsection{Document Objects}

\begin{classdesc}{Document}{}
The top-level node of a document that contains all other nodes.
\end{classdesc}

\begin{methoddesc}[Document]{createElement}{tagName}
instantiate a new element with the given name
\end{methoddesc}

\begin{methoddesc}[Document]{createDocumentFragment}{}
instantiate a new document fragment
\end{methoddesc}

\begin{methoddesc}[Document]{createTextNode}{data}
instantiate a new text node initialized with \var{data}
\end{methoddesc}

\begin{methoddesc}[Document]{importNode}{importedNode, deep=False}
import a node from another document.  If \var{deep} is true, all nodes
within \var{importedNode} are cloned.
\end{methoddesc}

\begin{methoddesc}[Document]{normalizeDocument}{}
concatenate all consecutive text nodes and remove comments
\end{methoddesc}



\section{\module{plasTeX} --- The Python Macro and Document Interfaces}

\declaremodule{standard}{plasTeX}
\modulesynopsis{The classes that make up a majority of the \plasTeX\ framework.}

While \plasTeX\ does a respectable job expanding \LaTeX\ macros, some macros
may be too complicated for it to handle.  These macros may have to be re-coded
as Python objects.  Another reason you may want to use Python-based macros
is for performance reasons.  In most cases, macros coded using Python will
be faster than those expanded as true \LaTeX\ macros.

The API for Python macros is much higher-level than that of \LaTeX\ macros.
This has good and bad ramifications.  The good is that most common forms
of \LaTeX\ macros can be parsed and processed very easily using Python code
which is easier to read than \LaTeX\ code.  The bad news is that if you 
are doing something that isn't common, you will have more work to do.
Below is a basic example.

\begin{verbatim}
from plasTeX import Command

class mycommand(Command):
    """ \mycommand[name]{title} """
    args = '[ name ] title'
\end{verbatim}

The code above demonstrates how to create a Python-based macro corresponding
to \LaTeX\ macro with the form \macro{mycommand[name]\{title\}} where `name'
is an optional argument and `title' is a mandatory argument.  In the Python
version of the macro, you simply declare the arguments in the \member{args}
attribute as they would be used in the \LaTeX\ macro, while leaving the braces
off of the mandatory arguments.  When parsed in a \LaTeX\ document, an instance
of the class \class{mycommand} in created and the arguments corresponding to
`name' and `title' are set in the \member{attributes} dictionary for that 
instance.  This is very similar to the way an XML DOM works, and there are
more DOM similarities yet to come.  In addition, there are ways to handle
casting of the arguments to various data types in Python.  The API documentation
below goes into more detail on these and many more aspects of the Python
macro API.

\subsection{Macro Objects}

\begin{classdesc}{Macro}{}
The \class{Macro} class is the base class for all Python based macros
although you will generally want to subclass from \class{Command} or 
\class{Environment} in real-world use.  There are various attributes and
methods that affect how Python macros are parsed, constructed and 
inserted into the resulting DOM.  These are described below.
\end{classdesc}

\begin{memberdesc}[Macro]{macroName}
specifies the name of the \LaTeX\ macro that this class corresponds to.  
By default, the Python class name is the name that is used, but there are
some legal \LaTeX\ macro names that are not legal Python class names.
In those cases, you would use \member{macroName} to specify the correct
name.  Below is an example.
\begin{verbatim}
class _illegalname(Command):
    macroName = '@illegalname'
\end{verbatim}
\note{This is a class attribute, not an instance attribute.}
\end{memberdesc}

\begin{memberdesc}[Macro]{macroMode}
specifies what the current parsing mode is for this macro.  Macro classes
are instantiated for every invocation including each \macro{begin} and 
\macro{end}.  This attribute is set to \member{Macro.MODE_NONE} for normal
commands, \member{Macro.MODE_BEGIN} for the beginning of an environment,
and \member{Macro.MODE_END} for the end of an environment.  

These attributes are used in the \method{invoke()} method to determine the
scope of macros used within the environment.  They are also used in printing
the source of the macro in the \member{source} attribute.  Unless you 
really know what you are doing, this should be treated as a read-only attribute.
\end{memberdesc}

\begin{memberdesc}[Macro]{mathMode}
boolean that indicates that the macro is in \TeX's ``math mode.''  This
is a read-only attribute.
\end{memberdesc}

\begin{memberdesc}[Macro]{level}
specifies the hierarchical level of the node in the DOM.  For most macros,
this will be set to \member{Node.COMMAND_LEVEL} or 
\member{Node.ENVIRONMENT_LEVEL} by the \class{Command} and \class{Environment}
macros, respectively.  However, there are other levels that invoke special
processing.  In particular, sectioning commands such as \macro{section} and
\macro{subsection} have levels set to \member{Node.SECTION_LEVEL} and 
\member{Node.SUBSECTION_LEVEL}.  These levels assist in the building of 
an appropriate DOM.  Unless you are creating a sectioning command or a command
that should act like a paragraph, you should leave the value of this attribute
alone.  See the section \titleref{dom} for more information.
\end{memberdesc}

\begin{memberdesc}[Macro]{counter}
specifies the name of the counter to associate with this macro.  Each time
an instance of this macro is created, this counter is incremented.  
The incrementing of this counter, of course, resets any ``child'' counters
just like in \LaTeX.  By default and \LaTeX\ convention, if the macro's first 
argument is an asterisk (i.e. *), the counter is not incremented.
\end{memberdesc}

\begin{memberdesc}[Macro]{ref}
specifies the value to return when this macro is referenced (i.e. \macro{ref}).
This is set automatically when the counter associated with the macro is
incremented.
\end{memberdesc}

\begin{memberdesc}[Macro]{idref}
specifies the node that this macro is referencing.  ???
\end{memberdesc}

\begin{memberdesc}[Macro]{argsource}
the source for the \LaTeX\ arguments to this macro.  This is a read-only 
attribute.
\end{memberdesc}

\begin{memberdesc}[Macro]{args}
specifies the arguments to the \LaTeX\ macro and their data types.  The
\member{args} attribute gives you a very simple, yet extremely powerful way
of parsing \LaTeX\ macro arguments and converting them into Python objects.
Once parsed, each \LaTeX\ macro argument is set in the \member{attributes}
dictionary of the Python instance using the name given in the \member{args}
string.  For example, the following \member{args} string will direct 
\plasTeX\ to parse two mandatory arguments, `id' and `title', and put them 
into the \member{attributes} dictonary.
\begin{verbatim}
args = 'id title'
\end{verbatim}

You can also parse optional arguments, usually surrounded by square brackets
(\lbrack~\rbrack).  However, in \plasTeX, any arguments specified in the 
\member{args}
string that aren't mandatory (i.e. no braces surrounding it) are automatically
considered optional.  This may not truly be the case, but it doesn't make
much difference.  If they truly are mandatory, then your \LaTeX\ source file will
always have them and \plasTeX\ will simply always find them even though it
considers them to be optional.  

Optional arguments in the \member{args} string are surround by matching
square brackets (\lbrack~\rbrack), angle brackets (<~>), or parentheses ((~)).
The name for the attribute is placed between the matching symbols as follows:
\begin{verbatim}
args = '[ toc ] title'
args = '( position ) object'
args = '< markup > ref'
\end{verbatim}
You can have as many optional arguments as you wish.  It is also possible to 
have optional arguments using braces (\{~\}), but this requires you
to change \TeX's category codes and is not common.

Modifiers such as asterisks (*) are also allowed in the \member{args} string.
You can also use the plus (+) and minus (-) signs as modifiers although these
are not common.  Using modifiers can affect the incrementing of counters (see
the \method{parse()} method for more information).

In addition to specifying which arguments to parse, you can also specify 
what the data type should be. 
By default, all arguments are processed and stored as document fragments.
However, some arguments may be simpler than that.  They may contain an integer,
a string, an ID, etc.  Others may be collections like a list or dictionary.
There are even more esoteric types for mostly internal use that allow you to
get unexpanded tokens, \TeX\ dimensions, and the like.  Regardless, all of 
these directives are specified in the same way, using the typecast operator:
`:'.  To cast an argument, simply place a colon (:) and the name of the 
argument type immediately after the name of the argument.  The following example
casts the `filename' argument to a string.
\begin{verbatim}
args = 'filename:str'
\end{verbatim}

Parsing compound arguments such as lists and dictionaries is very similar.
\begin{verbatim}
args = 'filenames:list'
\end{verbatim}
By default, compound arguments are assumed to be comma separated.  If you
are using a different separator, it is specified in parentheses after the type.
\begin{verbatim}
args = 'filenames:list(;)'
\end{verbatim}
Again, each element element in the list, by default, is a document fragment.
However, you can also give the data type of the elements with another typecast.
\begin{verbatim}
args = 'filenames:list(;):str'
\end{verbatim}

Parsing dictionaries is a bit more restrictive.  \plasTeX\ assumes that 
dictionary arguments are always key-value pairs, that the key is always
a string and the separator between the key and value is an equals sign (=).  
Other than that, they operate in the same manner.

A full list of the supported data types is shown below.

\textbf{Standard Types}
\begin{tableii}{l|l}{var}{Type Name}{Description}
\lineii{str}{a string}
\lineii{chr}{same as `str'}
\lineii{char}{same as `str'}
\lineii{label}{a string that is also a label.  If an argument is specified as 
a label, that node in the document is also labelled with that value so that 
the node can be referenced by other nodes.}
\lineii{id}{same as `label'}
\lineii{idref}{a string that refers to the ID of another node.  When this argument
is parsed, the \member{idref} attribute is set to the object that is 
referenced by that ID.}
\lineii{ref}{same as `idref'}
\lineii{number}{an integer}
\lineii{int}{same as `number'}
\lineii{count}{same as `number'}
\lineii{float}{a decimal value}
\lineii{double}{same as `float'}
\end{tableii}

\textbf{Compound Types}
\begin{tableii}{l|l}{var}{Type Name}{Description}
\lineii{list}{a list of values}
\lineii{dict}{key-value pairs}
\end{tableii}

\textbf{Internal Use and Esoteric Types}
\begin{tableii}{l|l}{var}{Type Name}{Description}
\lineii{cs}{\LaTeX\ control sequence}
\lineii{nox}{list of unexpanded tokens}
\lineii{dimen}{a \TeX\ dimension}
\lineii{dimension}{same as `dimen'}
\lineii{length}{same as `dimen'}
\end{tableii}
\end{memberdesc}

\begin{memberdesc}[Macro]{title}
specifies the title of the current object.  If the attributes dictionary
contains a title, that object is returned.  An \exception{AttributeError}
is thrown if there is no `title' key in that dictionary.  A title can also be 
set manually by setting this attribute.
\end{memberdesc}

\begin{memberdesc}[Macro]{style}
specifies style overrides, in CSS format, that should be applied to the
output.  This object is a dictionary, so style property names are given
as the key and property values are given as the values.
\begin{verbatim}
inst.style['color'] = 'red'
inst.style['background-color'] = 'blue'
\end{verbatim}
\note{Not all renderers are going to support CSS styles.}
\end{memberdesc}

\begin{memberdesc}[Macro]{id}
specifies a unique ID for the object.  If the object has an associated 
label (i.e. \macro{label}), that is its ID.  You can also set the ID 
manually.  Otherwise, an ID will be generated based on the result of Python's
\function{id()} function.
\end{memberdesc}

\begin{memberdesc}[Macro]{source}
specifies the \LaTeX\ source that was parsed to create the object.  This
is most useful in the renderer if you need to generate an image of a
document node.  You can simply retrieve the \LaTeX\ source from this 
attribute, create a \LaTeX\ document including the source, then convert
the DVI file to the appropriate image type.
\end{memberdesc}

\begin{memberdesc}[Macro]{arguments}
gives the arguments in the \member{args} attribute in object form 
(i.e. \class{Argument} objects).
\note{This is a read-only attribute.}
\note{This is generally an internal-use-only attribute.}
\end{memberdesc}

\begin{memberdesc}[Macro]{nodeName}
the name of the node in the DOM.  This will either be the name given in
\member{macroName}, if defined, or the name of the class itself.
\note{This is a read-only attribute.}
\end{memberdesc}

\begin{memberdesc}[Macro]{tagName}
same as \member{nodeName}
\end{memberdesc}

\begin{methoddesc}[Macro]{locals}{}
retrieves all of the \LaTeX\ macros that belong to the scope of the
current Python based macro.
\end{methoddesc}

\begin{methoddesc}[Macro]{invoke}{}
invakes the macro.  Invoking the macro, in the general case, includes 
creating a new context, parsing the options of the macro, and removing 
the context.  \LaTeX\ environments are slightly different.  If 
\member{macroMode} is set to \member{Macro.MODE\_BEGIN}, the new context
is kept on the stack.  If \member{macroMode} is set to \member{Macro.MODE\_END},
no arguments are parsed, the context is simply popped.  For most macros, the
default implementation will work fine.

The return value for this method is generally \var{None} (an empty return
statement or simply no return statement).  In this case, the current object
is simply put into the resultant output stream.  However, you can also
return a list of tokens.  In this case, the returned tokens will be put 
into the output stream in place of the current object.  You can even 
return an empty list to indicate that you don't want anything to be 
inserted into the output stream.
\end{methoddesc}

\begin{methoddesc}[Macro]{parse}{tex}
parses the arguments defined in the \member{args} attribute from the given
token stream.  This method also calls several hooks as described in the table
below.

\begin{tableii}{l|l}{method}{Method Name}{Description}
\lineii{preparse()}{called at the beginning of the argument parsing process}
\lineii{preargument()}{called before parsing each argument}
\lineii{postargument()}{called after parsing each argument}
\lineii{postparse()}{called at the end of the argument parsing process}
\end{tableii}

The methods are called to assist in labeling and counting.  For example,
by default, the counter associated with a macro is automatically incremented
when the macro is parsed.  However, if the first argument is a modifier 
(i.e. *, +, -), the counter will not be incremented.  This is handled 
in the \method{preargument()} and \method{postargument()} methods.

Each time an argument is parsed, the result is put into the \member{attributes}
dictionary.  The key in the dictionary is, of course, the name given to that
argument in the \member{args} string.  Modifiers such as *, +, and - are
stored under the special key `*modifier*'.

The return value for this method is simply a reference to the 
\member{attributes} dictionary.

\note{If \method{parse()} is called on an instance with \member{macroMode}
set to \member{Macro.MODE\_END}, no parsing takes place.}
\end{methoddesc}

\begin{methoddesc}[Macro]{stepcounter}{tex}
step the counter associated with the macro
\end{methoddesc}

\begin{methoddesc}[Macro]{refstepcounter}{tex}
set the object as the current labellable object and increment its counter.
When an object is set as the current labellable object, the next 
\macro{label} command will point to that object.
\end{methoddesc}

\begin{methoddesc}[Macro]{preargument}{arg, tex}
called before parsing each argument.  This is generally where label and
counter mechanisms are handled.

\var{arg} is the Argument instance that holds all argument meta-data
    including the argument's name, source, and options.

\var{tex} is the TeX instance containing the current context 
\end{methoddesc}

\begin{methoddesc}[Macro]{postargument}{arg, tex}
called after parsing each argument. This is generally where label and
counter mechanisms are handled.

\var{arg} is the Argument instance that holds all argument meta-data
    including the argument's name, source, and options.

\var{tex} is the TeX instance containing the current context 
\end{methoddesc}

\begin{methoddesc}[Macro]{preparse}{tex}
do any operations required immediately before parsing the arguments.
\end{methoddesc}

\begin{methoddesc}[Macro]{postparse}{tex}
do any operations required immediately after parsing the arguments.  This
generally includes setting up the value that will be returned when 
referencing the object.
\end{methoddesc}

\begin{methoddesc}[Macro]{digest}{tokens}
absorb the tokens from the given output stream that belong to the current
object.  In most commands, this does nothing.  However, \LaTeX\ environments
have a \macro{begin} and an \macro{end} that surround content that belong 
to them.  In this case, these environments need to absorb those tokens 
and construct them into the appropriate document object model (see the
\class{Environment} class for more information).
\end{methoddesc}

\begin{methoddesc}[Macro]{digestUntil}{tokens, endclass}
utility method to help macros like lists and tables digest their contents.
In lists and tables, the items, rows, and cells are delimited by 
\macro{begin} and \macro{end} tokens.  They are simply delimited by the
occurrence of another item, row, or cell.  This method allows you to
absorb tokens until a particular class is reached.
\end{methoddesc}

\begin{methoddesc}[Macro]{paragraphs}{}
group content into paragraphs.  Paragraphs are grouped once all other
content has been \method{digest}ed.  The paragraph grouping routine works
like \TeX's, in that environments are included inside paragraphs.  This 
is unlike HTML's model, where lists and tables are not included inside 
paragraphs.  In addition, content is only grouped into paragraphs if
a true \TeX\ paragraph exists (i.e. a blank line in the \LaTeX\ source file).
This can give seemingly strange behavior in constructs such as lists where
some items may have blank lines and others may not.  The items with blank
lines in the source will be grouped into paragraphs in the document 
object, but the items without would not have paragraphs.
\end{methoddesc}


\subsection{Command Objects}

\begin{classdesc}{Command}{}
The \class{Command} class is a subclass of \class{Macro}.  This is the class
that should be subclassed when creating Python based macros that correspond
to \LaTeX\ commands.

For more information on the \class{Command} class' API, see the 
\class{Macro} class.
\end{classdesc}


\subsection{Environment Objects}

\begin{classdesc}{Environment}{}
The \class{Environment} class is a subclass of \class{Macro}.  This is the
class that should be subclassed when creating Python based macros that 
correspond to \LaTeX\ environments.  The main difference between the 
processing of \class{Command}s and \class{Environment}s is that the
\method{invoke()} method does special handling of the \LaTeX\ document
context, and the \method{digest()} method absorbs the output stream tokens
that are encapsulated by the \macro{begin} and \macro{end} tokens. 

For more information on the \class{Environment} class' API, see the 
\class{Macro} class.
\end{classdesc}


\subsection{TeXFragment Objects}

\begin{classdesc}{TeXFragment}{}
A fragment of a document.  This class is used mainly to store the contents
of \LaTeX\ macro arguments.
\end{classdesc}

\begin{memberdesc}[TeXFragment]{source}
the \LaTeX\ source representation of the document fragment
\end{memberdesc}


\subsection{TeXDocument Objects}

\begin{classdesc}{TeXDocument}{}
A complete \LaTeX\ document.
\end{classdesc}

\begin{memberdesc}[TeXDocument]{preamble}
returns the \LaTeX\ source representation of the document preamble 
(i.e. everything before the \macro{begin\{document\}})
\end{memberdesc}

\begin{memberdesc}[TeXDocument]{source}
the \LaTeX\ source representation of the document 
\end{memberdesc}


\section{\module{plasTeX.TeX} --- The \TeX\ Stream}

\declaremodule{standard}{plasTeX.TeX}
\modulesynopsis{The \TeX\ stream processor}

The \TeX\ stream is the piece of \plasTeX\ where the parsing of the
\LaTeX\ document takes place.  While the \class{TeX} class is fairly
large, there are only a few methods and attributes designated in the
public API.  

The \TeX\ stream is based on a Python generator.  When you feed it
a \LaTeX\ source file, it processes the file much like \TeX\ itself.
However, on the output end, rather than a DVI file, you get a 
\plasTeX\ document object.  The basic usage is shown in the code below.
\begin{verbatim}
from plasTeX.TeX import TeX
doc = TeX(open('myfile.tex')).parse()
\end{verbatim}

\subsection{TeX Objects}

\begin{classdesc}{TeX}{source=None}
The \class{TeX} class is the central \TeX\ engine that does all of the 
parsing, invoking of macros, and other document building tasks.  The
only argument to the constructor is an optional Python file-like object.
This file object can accept non-ASCII sources as well using Python's 
\function{codecs.open()} function.  
\end{classdesc}

\begin{memberdesc}[TeX]{jobname}
the name of the basename at the top of the input stack
\end{memberdesc}

\begin{memberdesc}[TeX]{filename}
the current filename being processed
\end{memberdesc}

\begin{memberdesc}[TeX]{linenumber}
the line number of the current file being processed 
\end{memberdesc}

\begin{methoddesc}[TeX]{disableLogging}{}
disables logging.  This is useful if you are using the \class{TeX} object
within another library and do not want all of the status information to 
be printed to the screen.
\note{This is a class method.}
\end{methoddesc}

\begin{methoddesc}[TeX]{\_\_iter\_\_}{}
return a generator that iterates through the tokens in the source.  
This method allows you to treat the \class{TeX} stream as an iterable
and use it in looping constructs.  While the looping is generally
handled in the \method{parse()} method, you can manually expand the
tokens in the source by looping over the \class{TeX} object as well.
\begin{verbatim}
for tok in TeX(open('myfile.tex')):
    print tok
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[TeX]{expandtokens}{tokens, normalize=False}
expand a list of unexpanded tokens.  This method can be used to expand
tokens without having them sent to the output stream.  The returned value
is a \class{TeXFragment} populated with the expanded tokens.
\end{methoddesc}

\begin{methoddesc}[TeX]{parse}{output=None}
parse the sources currently in the input stack until they are empty.
The \var{output} argument is an optional \class{Document} node to put
the resulting nodes into.  If none is supplied, a \class{TeXDocument}
instance will be created.  The return value is the document from the
\var{output} argument or the instantiated \class{TeXDocument} object.
\end{methoddesc}

\begin{methoddesc}[TeX]{input}{source}
add a new input source to the input stack.  \var{source} should be
a Python file object.  This can be used to add additional input sources
to the stream after the \class{TeX} object has been instantiated.
\end{methoddesc}

\begin{methoddesc}[TeX]{texttokens}{text}
convert a string of text into a series of tokens
\end{methoddesc}

\begin{methoddesc}[TeX]{source}{tokens}
return the \LaTeX\ representation of the tokens in \var{tokens}
\end{methoddesc} 

\begin{methoddesc}[TeX]{readArgument}{*args, **kwargs}
parse a macro argument without the \LaTeX\ source that created it.
This method is just a thin wrapper around \method{readArgumentAndSource}.
See that method for more information.
\end{methoddesc}

\begin{methoddesc}[TeX]{readArgumentAndSource}{spec=None, subtype=None, 
       delim=',', expanded=False, default=None, parentNode=None, name=None}
parse a macro argument.  Return the argument and the \LaTeX\ source that
created it.  The arguments are described below.

\begin{tableii}{l|l}{var}{Option}{Description}
\lineii{spec}{string containing information about the type of
            argument to get.  If it is 'None', the next token is
            returned.  If it is a two-character string, a grouping
            delimited by those two characters is returned (i.e. '[]').
            If it is a single-character string, the stream is checked
            to see if the next character is the one specified.  
            In all cases, if the specified argument is not found,
            'None' is returned.}
\lineii{type}{data type to cast the argument to.  New types can be
            added to the self.argtypes dictionary.  The key should
            match this 'type' argument and the value should be a callable
            object that takes a list of tokens as the first argument
            and a list of unspecified keyword arguments (i.e. **kwargs)
            for type specific information such as list delimiters.}
\lineii{subtype}{data type to use for elements of a list or dictionary}
\lineii{delim}{item delimiter for list and dictionary types}
\lineii{expanded}{boolean indicating whether the argument content
            should be expanded or just returned as an unexpanded 
            text string}
\lineii{default}{value to return if the argument doesn't exist}
\lineii{parentNode}{the node that the argument belongs to}
\lineii{name}{the name of the argument being parsed}
\end{tableii}

The return value is always a two-element tuple.  The second value is always
a string.  However, the first value can take the following values.

\begin{tableii}{l|l}{}{Value}{Condition}
\lineii{None}{the requested argument wasn't found}
\lineii{object of requested type}{if \var{type} was specified}
\lineii{list of tokens}{all other arguments}
\end{tableii}

\end{methoddesc}

\begin{methoddesc}[TeX]{kpsewhich}{name}
locate the given file in a kpsewhich-like manner.  The full path to the
file is returned if it is found; otherwise, \var{None} is returned.
\note{Currently, only the directories listed in the environment variable
\envvar{TEXINPUTS} are searched.}
\end{methoddesc}


\section{\module{plasTeX.Context} --- The \TeX\ Context}

\declaremodule{standard}{plasTeX.Context}
\modulesynopsis{The \TeX\ document context}

The \class{Context} class stores all of the information associated with
the currently running document.  This includes things like macros, counters, 
labels, references, etc.  The context also makes sure that localized macros
get popped off when processing leaves a macro or environment.  The context
of a document also has the power to create new counters, dimens, if commands,
macros, as well as change token category codes.

Each time a \class{TeX} object is instantiated, it will create its own 
context.  This context will load all of the base macros and initialize
all of the context information described above.


\subsection{Context Objects}

\begin{classdesc}{Context}{\optional{load}}
Instantiate a new context.

If the \var{load} argument is set to true, the context will load all of the
base macros defined in \plasTeX.  This includes all of the macros used in 
the standard \TeX\ and \LaTeX\ distributions.
\end{classdesc}

\begin{memberdesc}[Context]{contexts}
stack of all macro and category code collections currently in the document 
being processed.  The item at index 0 include the global macro set and 
default category codes.
\end{memberdesc}

\begin{memberdesc}[Context]{currentlabel}
the object that is given the label when a \macro{label} macro is invoked.
\end{memberdesc}

\begin{memberdesc}[Context]{labels}
a dictionary of labels and the objects that they refer to.
\end{memberdesc}

\begin{memberdesc}[Context]{counters}
a dictionary of counters.
\end{memberdesc}

\begin{memberdesc}[Context]{packages}
a dictionary of \LaTeX\ packages.  The keys are the names of the packages.
The values are dictionaries containing the options that were specified
when the package was loaded.
\end{memberdesc}

\begin{memberdesc}[Context]{isMathMode}
boolean that specifies if we are currently in \TeX's math mode or not.
\end{memberdesc}

\begin{methoddesc}[Context]{loadBaseMacros}{}
imports all of the base macros defined by \plasTeX.  This includes all of
the macros specified by the \TeX\ and \LaTeX\ systems.
\end{methoddesc}

\begin{methoddesc}[Context]{label}{label}
set the given label to the currently labelable object.  An object can 
only have one label associated with it.
\end{methoddesc}

\begin{methoddesc}[Context]{ref}{obj, label}
set up a reference for resolution.  

\var{obj} is the macro object that is doing the referencing.

\var{label} is the label of the node that \var{obj} is looking for.

If the item that \var{obj} is looking for has already been labeled, 
the \member{idref} attribute of \var{obj} is set to the abject.  
Otherwise, the reference is stored away to be resolved later. 
\end{methoddesc}

\begin{methoddesc}[Context]{\_\_getitem\_\_}{key}
look through the stack of macros and return the one with the name \var{key}.
The return value is an \emph{instance} of the requested macro,
not a reference to the macro class.
This method allows you to use Python's dictionary syntax to retrieve
the item from the context as shown below.
\begin{verbatim}
tex.context['section']
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[Context]{push}{\optional{context}}
add a new scope to the stack.  If a macro instance \var{context} is specified, 
the new scope's namespace is given by that object.
\end{methoddesc}

\begin{methoddesc}[Context]{append}{\optional{context}}
same as \method{push()}
\end{methoddesc}

\begin{methoddesc}[Context]{importMacros}{context}
import macros from another context into the global namespace.  The argument,
\var{context}, must be a dictionary of macros.
\end{methoddesc}

\begin{methoddesc}[Context]{pop}{\optional{obj}}
pop the top scope off of the stack.  If \var{obj} is specified, continue
to pop scopes off of the context stack until the scope that was originally
added by \var{obj} is found.  
\end{methoddesc}

\begin{methoddesc}[Context]{addGlobal}{key, value}
add a macro \var{value} with name \var{key} to the global namespace. 
\end{methoddesc}

\begin{methoddesc}[Context]{addLocal}{key, value}
add a macro \var{value} with name \var{key} to the current namespace. 
\end{methoddesc}

\begin{methoddesc}[Context]{whichCode}{char}
return the character code that \var{char} belongs to.  The category
codes are the same codes used by \TeX\ and are defined in the 
\class{Token} class.  
\end{methoddesc}

\begin{methoddesc}[Context]{catcode}{char, code}
set the category code for a character in the current scope.  \var{char}
is the character that will have its category code changed.  \var{code}
is the \TeX\ category code (0-15) to change it to.
\end{methoddesc}

\begin{methoddesc}[Context]{setVerbatimCatcodes}{}
set the current set of category codes to the set used for the verbatim
environment.
\end{methoddesc}

\begin{methoddesc}[Context]{newcounter}{name, \optional{resetby\optional{, initial\optional{, format}}}}
create a new counter like \macro{newcounter}.

\var{name} is the name of the counter to create.

\var{resetby} is the counter that, when incremented, will reset the 
new counter.

\var{initial} is the initial value for the counter.

\var{format} is the printed format of the counter.

In addition to creating a new counter macro, another macro corresponding
to the \macro{the\var{name}} is created which prints the value of the
counter just like in \LaTeX.
\end{methoddesc}

\begin{methoddesc}[Context]{newcount}{name\optional{, initial}}
create a new count like \macro{newcount}.
\end{methoddesc}

\begin{methoddesc}[Context]{newdimen}{name\optional{, initial}}
create a new dimen like \macro{newdimen}.
\end{methoddesc}

\begin{methoddesc}[Context]{newskip}{name\optional{, initial}}
create a new skip like \macro{newskip}.
\end{methoddesc}

\begin{methoddesc}[Context]{newmuskip}{name\optional{, initial}}
create a new muskip like \macro{newmuskip}.
\end{methoddesc}

\begin{methoddesc}[Context]{newif}{name\optional{, initial}}
create a new if like \macro{newif}.  This also creates macros corresponding
to \macro{\var{name}true} and \macro{\var{name}false}.
\end{methoddesc}

\begin{methoddesc}[Context]{newcommand}{name\optional{, nargs\optional{, definition\optional{, opt}}}}
create a new \LaTeX\ command like \macro{newcommand}.

\var{name} is the name of the macro to create.

\var{nargs} is the number of arguments including optional arguments.

\var{definition} is a string containing the macro definition.

\var{opt} is a string containing the default optional value.

\textbf{Examples}
\begin{verbatim}
c.newcommand('bold', 1, r'\\textbf{#1}')
c.newcommand('foo', 2, r'{\\bf #1#2}', opt='myprefix')
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[Context]{newenvironment}{name\optional{, nargs\optional{, definition\optional{, opt}}}}
create a new \LaTeX\ environment like \macro{newenvironment}.  This works
exactly like the \method{newcommand()} method, except that the 
\var{definition} argument is a two element tuple where the first element
is a string containing the macro content to expand at the \macro{begin},
and the second element is the macro content to expand at the \macro{end}.

\textbf{Example}
\begin{verbatim}
c.newenvironment('mylist', 0, (r'\\begin{itemize}', r'\\end{itemize}'))
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[Context]{newdef}{name\optional{, args\optional{, definition\optional{, local}}}}
create a new \TeX\ definition like \macro{def}.

\var{name} is the name of the definition to create.

\var{args} is a string containing the \TeX\ argument profile.

\var{definition} is a string containing the macro code to expand when the
definition is invoked.

\var{local} is a boolean that specifies that the definition should only
exist in the local scope.  The default value is true.

\textbf{Examples}
\begin{verbatim}
c.newdef('bold', '#1', '{\\bf #1}')
c.newdef('put', '(#1,#2)#3', '\\dostuff{#1}{#2}{#3}')
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[Context]{let}{dest, source}
create a new \TeX\ let like \macro{let}.

\var{dest} is the command sequence to create.

\var{source} is the token to set the command sequence equivalent to.

\textbf{Example}
\begin{verbatim}
c.let('bgroup', BeginGroup('{'))
\end{verbatim}
\end{methoddesc}

\begin{methoddesc}[Context]{chardef}{name, num}
create a new \TeX\ chardef like \macro{chardef}.

\var{name} is the name of the command to create.

\var{num} is the character number to use.
\end{methoddesc}


\section{\module{plasTeX.Renderers} --- The \plasTeX\ Rendering Framework}

\declaremodule{standard}{plasTeX.Renderers}
\modulesynopsis{The \plasTeX\ rendering framework}


The renderer is responsible for taking the information in a \plasTeX\
document object and creating a another (usually visual) representation of it.  
This representation may be HTML, XML, RTF, etc.  While this could be
implemented in various ways.  One rendering framework is included with
\plasTeX.

The renderer is essentially just a dictionary of callable objects.  The
keys in this dictionary correspond to names of the nodes in the document
object.  The values are the callable objects that are called when a
node in the document object needs to be rendered.  The only argument
to the callable object is the node itself.  What this callable object
does in the rendering process is completely up to it; however, it should
refrain from changing the document object itself as other renderers 
may be using that same object.

There are some responsibilities that all renderers share.  Renderers
are responsible for checking options in the configuration object.
For instance, renderers are responsible for generating filenames, 
creating directories, writing files in the proper encoding, generating
images, splitting the document into multiple output files, etc.
Of course, how it accomplishes this is really renderer dependent.
An example of a renderer based on Zope Page Templates (ZPT) is included
with \plasTeX.  This renderer is capable of generating XML and HTML
output.


\subsection{Renderer Objects}

\begin{classdesc}{Renderer}{}
Base class for all renderers.  \class{Renderer} is a dictionary and
contains callable objects that are called for each node in the \plasTeX\
document object.  The keys in the dictionary correspond to the names of
the nodes.
\end{classdesc}

This renderer implementation uses a mixin called \class{Renderable} that
is mixed into the \class{Node} class prior to rendering.  \class{Renderable}
adds various methods to the \class{Node} namespace to assist in the
rendering process.  The primary inclusion is the \method{\_\_unicode\_\_()}
method.  This method returns a unicode representation of the current node
and all of its child nodes.  For more information, see the \class{Renderable}
class documentation.

\begin{memberdesc}[Renderer]{default}
the default renderer value.  If a node is being rendered and no key in
the renderer matches the name of the node being rendered, this 
callable is used instead.
\end{memberdesc}

\begin{memberdesc}[Renderer]{textdefault}
the default renderer to use for text nodes.
\end{memberdesc}

\begin{memberdesc}[Renderer]{files}
a list of files created during rendering.
\end{memberdesc}

\begin{memberdesc}[Renderer]{outputtype}
a callable object that converts the content returned from each rendered
node to the appropriate value.
\end{memberdesc}

\begin{memberdesc}[Renderer]{newfilename}
filename generator.  This method generates a basename based on the options
in the configuration.  

The generator has an attribute called \member{namespace} which contains the
namespace used to resolve the variables in the filename string.  This
namespace should be populated prior to invoking the generator.  After
a successful filename is generated, the namespace is automatically cleared
(with the exception of the variables sent in the namespace when the 
generator was instantiated).

\note{This generator can be accessed in the usual generator fashion, or
called like a function.}
\end{memberdesc}

\begin{memberdesc}[Renderer]{imager}
a reference to an \class{Imager} implementation.  Imagers are responsible
for generating images from \LaTeX\ code.  This is needed for output types 
which aren't capable of displaying equations, \LaTeX\ pictures, etc. such
as HTML.
\end{memberdesc}

\begin{methoddesc}[Renderer]{initialize}{}
this routine is called after the renderer is instantiated.  It can be used
by subclasses to do any initialization routines before the rendering process.
\end{methoddesc}

\begin{methoddesc}[Renderer]{render}{document}
invokes the rendering process on \var{document}.
\end{methoddesc}

\begin{methoddesc}[Renderer]{cleanup}{document, files}
this method is called once the entire rendering process is finished.  
Subclasses can use this method to run any post-rendering cleanup tasks.
The first argument, \var{document}, is the document instance that is
being rendered.  The second argument, \var{files}, is a list of all of the
filenames that were created.
\end{methoddesc}

\begin{methoddesc}[Renderer]{find}{keys\optional{, default}}
locate a rendering method from a list of possibilities.  

\var{keys} is a list of strings containing the requested name of a
rendering method.  This list is traversed in order.  The first renderer
that is found is returned.

\var{default} is a default rendering method to return if none of the keys
exists in the renderer.
\end{methoddesc}


\subsection{Renderable MixIn}

\begin{classdesc}{Renderable}{}
The \class{Renderable} mixin is mixed into the \class{Node} namespace
prior to the rendering process.  The methods mixed in assist in the 
rendering process.
\end{classdesc}

\begin{memberdesc}[Renderable]{image}
generate an image of the object and return the image filename.
\end{memberdesc}

\begin{memberdesc}[Renderable]{url}
return the relative URL of the object.  

If the object actually creates a file, just the filename will
be returned (e.g. \file{foo.html}).  If the object is within a file, 
both the filename and the anchor will be returned 
(e.g. \file{foo.html\#bar}).
\end{memberdesc}

\begin{memberdesc}[Renderable]{filename}
the filename that this object will create.  Objects that don't create 
new files should simply return \var{None}.   The configuration determines
which nodes should create new files. 
\end{memberdesc}

\begin{methoddesc}[Renderable]{\_\_unicode\_\_}{}
invoke the rendering process on all of the child nodes.  The rendering process
includes walking through the child nodes, looking up the appropriate 
rendering method from the renderer, and calling the method with the child
node as its argument.

In addition to the actual rendering process, this method also prints out 
some status information about the rendering process.  For example, if 
the node being rendered has a non-empty \member{filename} attribute, that
means that the node is generating a new file.  This filename information
is printed to the log.  One problem with this methodology is that the 
filename is not actually created at this time.  It is assumed that the
rendering method will check for the \member{filename} attribute and actually
create the file.
\end{methoddesc}

\begin{methoddesc}[Renderable]{\_\_str\_\_}{}
same as \method{\_\_unicode\_\_()}.
\end{methoddesc}


\chapter{Parsing a \LaTeX\ Document from Python Code}

For most people, the inluded command-line program, \program{plastex}, 
will be used to invoke the parsing and rendering process, but if you
want to manipulate the DOM and do your own rendering you might want
to do the parsing yourself. Luckily, converting a \LaTeX\ file into a
\plasTeX\ DOM is quite simple.  We'll use the following \LaTeX\ source for 
our examples.

\begin{verbatim}
\documentclass{article}
\newcommand{\strong}[1]{\textbf{#1}}
\begin{document}

\section{Section One}

Paragraph one.

\begin{itemize}
\item a
\item \strong{b} 
\item c
\end{itemize}

Paragraph two.

\end{document}
\end{verbatim}

Parsing the document is as simple as this.

\begin{verbatim}
from plasTeX.TeX import TeX
dom = TeX(open('mylatex.tex')).parse()
\end{verbatim}

All you do is instantiate a \class{TeX} object with a file-like object as 
its first argument.  When the \method{parse()} method is invoked on the
instance, the file object is parsed.  Note that the TeX parser is capable
of parsing non-ASCII encodings.

If you don't want the logging information to be printed out during parsing,
you can use the \method{disableLogging()} method on the \TeX\ object.

\begin{verbatim}
TeX.disableLogging()
\end{verbatim}

If you want to see what is in the DOM, you can use the \method{toXML()} method.
This prints out XML such that each XML node's name is the same as the 
\LaTeX\ macro that created it.  You will also see some XML nodes in the 
\member{plastex} namespace.  These generally correspond to nodes that
are used in creating the DOM structure, but that aren't part of the 
source document's structure.  For the most part, these come from 
\LaTeX\ macro arguments.

\begin{verbatim}
print dom.toXML()
\end{verbatim}

The \method{toXML()} method will print out XML similar to the following.

\begin{verbatim}
<dom-document>
<documentclass>
    <plastex:arg name="options"/>
    <plastex:arg name="name">article</plastex:arg>
</documentclass> 
<newcommand>
    <plastex:arg name="opt"/>
    <plastex:arg name="definition">[u'textbf', u'{', u'#', u'1', u'}']</plastex:arg>
    <plastex:arg name="*modifier*"/>
    <plastex:arg name="nargs">1</plastex:arg>
    <plastex:arg name="name">strong</plastex:arg>
</newcommand> 
<document>
<section ref="1">
    <plastex:arg name="toc"/>
    <plastex:arg name="*modifier*"/>
    <plastex:arg name="title">Section One</plastex:arg>
<par> Paragraph one. </par>
<par>
<itemize>
    <item ref="1"> <plastex:arg name="term"/> a </item>
    <item ref="2"> <plastex:arg name="term"/> 
        <textbf> <plastex:arg name="self">b</plastex:arg> b</textbf> 
    </item>
    <item ref="3"> <plastex:arg name="term"/> c </item>
</itemize>
Paragraph two. </par>
</section>
</document> 
</dom-document>
\end{verbatim}

Since \LaTeX\ code is pretty free-form and can include macros, there 
is no DTD for the XML that is generated by the \method{toXML()} method.

Now, do you want to see something \textit{really} cool?  Try this:

\begin{verbatim}
print dom.source
\end{verbatim}

Viola!  You now have the source of the document where all of the macros 
defined in the \LaTeX\ source have been expanded.

\begin{verbatim}
\documentclass{article} 
\newcommand{\strong }[1]{\textbf {#1}} 
\begin{document} 
\section{Section One}
Paragraph one. 

\begin{itemize} 
\item a 
\item \textbf{b} 
\item c 
\end{itemize}
Paragraph two. 

\end{document} 
\end{verbatim}

The \member{source} property exists on all DOM nodes, so any time you want
to see the source that created that node you can look at the \member{source}
attribute.  This is very handy in rendering equations if you need to generate
images from the \LaTeX\ source.


\appendix

\chapter{Frequently Asked Questions}

\section{Parsing \LaTeX}

\question{\plasTeX\ can't seem to handle my complicated macros. What can 
    I do about it?}

While \plasTeX\ makes a valiant effort 
to expand all \LaTeX\ macros, it isn't \TeX\ and may have problems if 
your macros are complicated.  There are things that you can do to remedy the 
situation.  If you are getting failures or warnings, you can do one of two 
things: 1) you can create a simplified version of the macro that \plasTeX\ uses
for its work, while \LaTeX\ uses the more complicated one, or 2) you
can implement the macro as a Python class. 

In the first solution, you can use the \macro{ifplastex} construct to wrap
your \plasTeX\ and \LaTeX\ versions of the macros.  You can even just remove 
parts of the macros.  See the example below.

\begin{verbatim}
% Print a double line, then bold the text.  
% In plasTeX, leave the lines out.
\newcommand{\mymacro}[1]{\ifplastex\else\hline\hline\fi\textbf{#1}}
\end{verbatim}

Depending on how complicated you macro is, you may want to implement it
as a Python class instead of a \LaTeX\ macro.  Using a Python class 
gives you full access to all of the \plasTeX\ internal mechanisms to 
do whatever you need to do in your macro.  To read more about writing
Python class macros, see the section \ref{pythonmacros}.

\question{\plasTeX\ can't find my \LaTeX\ package.  How do I point \plasTeX\ 
    in the right direction?}

There are two types of packages that can be loaded by \plasTeX: 1) native
\LaTeX\ packages, and 2) packages written entirely in Python.  \plasTeX\
first looks for packages written in Python.  Packages such as this are
written specifically for \plasTeX\ and will yield better parsing performance
as well as better looking output.  Python-based packages are valid Python
packages as well.  So to load them, you must add the directory where
your Python packages are to your \envvar{PYTHONPATH} environment variable.
For more information about Python-based packages, see the section
\ref{pythonpackages}.

If you have a true \LaTeX\ package, \plasTeX\ will try to locate it using
the \program{kpsewhich} program just like \LaTeX\ does.


\end{document}
